""" Одним из самых часто используемых классов в Python является класс filter. Он принимает в конструкторе два аргумента a и f – последовательность и функцию,
и позволяет проитерироваться только по таким элементам x из последовательности a, что f(x) равно True. 
Будем говорить, что в этом случае функция f допускает элемент x, а элемент x является допущенным.

В данной задаче мы просим вас реализовать класс multifilter, который будет выполнять ту же функцию, что и стандартный класс filter,
но будет использовать не одну функцию, а несколько.
Решение о допуске элемента будет приниматься на основании того, сколько функций допускают этот элемент, и сколько не допускают.
Обозначим эти количества за pos и neg.

Введем понятие решающей функции – это функция, которая принимает два аргумента – количества pos и neg, и возвращает True, если элемент допущен, и False иначе.

Рассмотрим процесс допуска подробнее на следующем примере.
a = [1, 2, 3]
f2(x) = x % 2 == 0 # возвращает True, если x делится на 2
f3(x) = x % 3 == 0
judge_any(pos, neg) = pos >= 1 # возвращает True, если хотя бы одна функция допускает элемент

В этом примере мы хотим отфильтровать последовательность a и оставить только те элементы, которые делятся на два или на три.
Функция f2 допускает только элементы, делящиеся на два, а функция f3 допускает только элементы, делящиеся на три. 
Решающая функция допускает элемент в случае, если он был допущен хотя бы одной из функций f2 или f3, то есть элементы, которые делятся на два или на три.

Возьмем первый элемент x = 1.
f2(x) равно False, т. е. функция f2 не допускает элемент x.
f3(x) также равно False, т. е. функция f3 также не допускает элемент x.
В этом случае pos = 0, так как ни одна функция не допускает x, и соответственно neg = 2.
judge_any(0, 2) равно False, значит мы не допускаем элемент x = 1.

Возьмем второй элемент x = 2.
f2(x) равно True
f3(x) равно False
pos = 1, neg = 1
judge_any(1, 1) равно True, значит мы допускаем элемент x = 2.

Аналогично для третьего элемента x = 3.
Таким образом, получили последовательность допущенных элементов [2, 3]. """

class multifilter:
    def judge_half(pos, neg):
        if pos >= neg:
            return True
        return False

    def judge_any(pos, neg):
        if pos >= 1:
            return True
        return False

    def judge_all(pos, neg):
        if neg == 0:
            return True
        return False

    def __init__(self, iterable, *funcs, judge=judge_any):
        self.iterable = iterable
        self.funcs = funcs
        self.judge = judge

    def __iter__(self):
        for elem in self.iterable:
            pos, neg = 0, 0
            for j in self.funcs:
                if j(elem):
                    pos += 1
                else:
                    neg += 1
            if self.judge(pos, neg):
                yield elem

""" Вам дана последовательность строк. Выведите строки, содержащие "cat" в качестве подстроки хотя бы два раза. """

import sys
import re

for line in sys.stdin:
    line = line.rstrip()
    res = re.search("cat.*cat", line)
    if res != None:
        print(line)

""" Вам дана последовательность строк. Выведите строки, содержащие "cat" в качестве слова. """

import sys
import re

for line in sys.stdin:
    line = line.rstrip()
    if re.search(r"\bcat\b", line):
        print(line)

""" Вам дана последовательность строк. Выведите строки, содержащие две буквы "z", между которыми ровно три символа. """
        
import sys
import re

for line in sys.stdin:
    line = line.rstrip()
    if re.search(r"z.{3}z", line):
        print(line)  
        
""" Вам дана последовательность строк. Выведите строки, содержащие обратный слеш "\". """
        
import sys
import re

for line in sys.stdin:
    line = line.rstrip()
    if re.search(r"\\", line):
        print(line) 
        
""" Вам дана последовательность строк. Выведите строки, содержащие слово, состоящее из двух одинаковых частей (тандемный повтор). """
  
import sys
import re

for line in sys.stdin:
    line = line.rstrip()
    if re.search(r"\b(\w+)\1\b", line):
        print(line)
  
""" Вам дана последовательность строк. В каждой строке замените все вхождения подстроки "human" на подстроку "computer" и выведите полученные строки. """  
  
import sys
import re

for line in sys.stdin:
    line = line.rstrip()
    print(re.sub(r"human", "computer", line)) 
  
""" Вам дана последовательность строк. В каждой строке замените первое вхождение слова, состоящего только из латинских букв "a" (регистр не важен), на слово "argh". """
  
import sys
import re

for line in sys.stdin:
    line = line.rstrip()
    print(re.sub(r"\b[aA]+\b", "argh", line, count=1))
  
""" Вам дана последовательность строк. В каждой строке поменяйте местами две первых буквы в каждом слове, состоящем хотя бы из двух букв.
Буквой считается символ из группы \w. """

import sys
import re

for line in sys.stdin:
    line = line.rstrip()
    print(re.sub(r"\b(\w)(\w)", r"\2\1", line))

""" Вам дана последовательность строк. В каждой строке замените все вхождения нескольких одинаковых букв на одну букву.
Буквой считается символ из группы \w. """

import sys
import re

for line in sys.stdin:
    line = line.rstrip()
    print(re.sub(r"(\w)\1+", r"\1", line))
